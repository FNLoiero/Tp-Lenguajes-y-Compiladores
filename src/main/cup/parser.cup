package lyc.compiler;

import java_cup.runtime.*;
import java.util.Stack;
import lyc.compiler.model.NodoArbol;

class Parser;

parser code {:    
    private Stack<Object> variables = new Stack<Object>();
    private NodoArbol arbolSintactico = null;
    
    // Función para crear un nodo del árbol sintáctico
    private NodoArbol crearNodo(String operador, NodoArbol hijoIzquierdo, NodoArbol hijoDerecho) {
        return new NodoArbol(operador, hijoIzquierdo, hijoDerecho);
    }
    
    // Función para crear una hoja del árbol sintáctico
    private NodoArbol crearHoja(String valor) {
        return new NodoArbol(valor);
    }
    
    // Función para obtener el árbol sintáctico generado
    public NodoArbol getArbolSintactico() {
        return arbolSintactico;
    }
:};


// Terminals
terminal ID;
terminal CTE_ENTERA;
terminal CTE_FLOTANTE;
terminal CTE_CADENA;

terminal OP_SUMA;
terminal OP_RESTA;
terminal OP_MULT;
terminal OP_DIV;
terminal OP_ASIG;
terminal COMP_MEN;
terminal COMP_MAY;

terminal OP_COMA;
terminal PAR_ABRIR;
terminal PAR_CERRAR;
terminal LLAVE_ABRIR;
terminal LLAVE_CERRAR;
terminal OP_PUNTOS;

terminal IF;
terminal ELSE;
terminal WHILE;
terminal AND;
terminal OR;
terminal NOT;
terminal WRITE;
terminal READ;
terminal INIT;

terminal DT_FLOAT;
terminal DT_INT;
terminal DT_STRING;

// Terminales especiales
terminal EQUAL_EXPRESSIONS;
terminal IS_ZERO;
terminal COMENTARIO;

// Non Terminals

    //Comunes
    non terminal programa;
    non terminal instruccion;
    non terminal serie_de_instrucciones;
    non terminal instruccion_normal;
    non terminal asignacion;
    non terminal constante;
    non terminal tipo_dato;

    //INIT
    non terminal inicializacion;    
    non terminal declaraciones;    
    non terminal listado_variables;

    //Aritmeticos    
    non terminal operacion;
    non terminal termino;
    non terminal factor;     

    //Condicionales
    non terminal instruccion_condicional;
    non terminal if;
    non terminal while;
    non terminal condicion;    
    non terminal else_opcional;
    non terminal expresion_logica;
    non terminal comparador;

    //Especiales
    non terminal instruccion_especial;
    non terminal parametros_operaciones;
    non terminal operation_equal_expressions;
    non terminal operation_is_zero;

    //Entrada y salida
    non terminal instruccion_entrada_salida;
    non terminal read;
    non terminal write;
    non terminal parametro_write;
     
//

// Start Symbol Definition

start with programa;

programa ::= serie_de_instrucciones:instrucciones {: 
                        arbolSintactico = (NodoArbol)instrucciones;
                        System.out.println("FIN"); 
                    :};
serie_de_instrucciones ::= instruccion:inst {: RESULT = inst; :} 
                        | serie_de_instrucciones:lista instruccion:inst {:                             
                            RESULT = crearNodo("instrucción", (NodoArbol)lista, (NodoArbol)inst);
                          :};

//Tipos de instrucciones

    instruccion ::=  instruccion_normal:inst {: RESULT = inst; :}
                    | instruccion_condicional:inst {: RESULT = inst; :}
                    | instruccion_entrada_salida:inst {: RESULT = inst; :}
                    | instruccion_especial:inst {: RESULT = inst; :};
    instruccion_normal ::= asignacion:asig {: RESULT = asig; :} 
                        | inicializacion:init {: RESULT = init; :};    
    instruccion_condicional ::= if:ifInst {: RESULT = ifInst; :} 
                              | while:whileInst {: RESULT = whileInst; :};
    instruccion_entrada_salida ::= read:readInst {: RESULT = readInst; :} 
                                 | write:writeInst {: RESULT = writeInst; :};
    instruccion_especial ::= operation_equal_expressions:equal {: RESULT = equal; :} 
                            | operation_is_zero:isZero {: RESULT = isZero; :};

//Operaciones detalladas

    //----------- Instrucciones normales

    asignacion ::= ID:id OP_ASIG operacion:expr {: 
                        String tipoVar = lyc.compiler.files.SymbolTableGenerator.GetTipo((String)id);
                        if (tipoVar == null || tipoVar == "") {
                            throw new RuntimeException("Error: variable '" + id + "' no declarada.");
                        }
                        RESULT = crearNodo(":=", crearHoja((String)id), (NodoArbol)expr);
                        String lexExpr = ((NodoArbol)expr) != null ? ((NodoArbol)expr).getValor() : "";
                        System.out.println("Se asignó el ID: " + (String)id + " con lexema: " + lexExpr);
                    :}
                 | ID:id OP_ASIG operation_equal_expressions:expr {: 
                        RESULT = crearNodo(":=", crearHoja((String)id), (NodoArbol)expr);
                        System.out.println("Se asigno el equal expressions");
                    :}
                 | ID:id OP_ASIG operation_is_zero:expr {: 
                        RESULT = crearNodo(":=", crearHoja((String)id), (NodoArbol)expr);
                        System.out.println("Se asigno el operation is zero");
                    :};

                 
    constante ::= CTE_ENTERA:valor {: 
                        RESULT = crearHoja((String)valor);
                        System.out.println("Entero usado: " + (String)valor);
                    :}
                | CTE_FLOTANTE:valor {: 
                        RESULT = crearHoja((String)valor);
                        System.out.println("Flotante usado: " + (String)valor);
                    :}
                | CTE_CADENA:valor {: 
                        RESULT = crearHoja((String)valor);
                        System.out.println("Cadena usada: " + (String)valor);
                    :};

    tipo_dato ::= DT_FLOAT
                    {:
                        RESULT = "Float";
                        System.out.println("Declaracion Float");
                    :}
                | DT_INT
                    {:
                        RESULT = "Int";
                        System.out.println("Declaracion Int");
                    :}
                | DT_STRING
                    {:
                        RESULT = "String";
                        System.out.println("Declaracion String");
                    :};

    inicializacion ::= INIT LLAVE_ABRIR declaraciones LLAVE_CERRAR{:                        
                        System.out.println("Bloque INIT");
                    :};

    declaraciones ::=  listado_variables:vars OP_PUNTOS tipo_dato:tipo {:
                        for (Object IdUtilizar : variables) {
                            lyc.compiler.files.SymbolTableGenerator.SetTipo(IdUtilizar, (String)tipo);                            
                        }                        
                        variables = new Stack<Object>(); 
                    :}    
    | declaraciones:decls listado_variables:vars OP_PUNTOS tipo_dato:tipo    
    {:
        for (Object IdUtilizar : variables) {
            lyc.compiler.files.SymbolTableGenerator.SetTipo(IdUtilizar, (String)tipo);                            
        }        
        variables = new Stack<Object>(); 
    :};

    listado_variables ::= ID:id {: 
                            variables.push(id);
                            RESULT = crearHoja((String)id);
                            System.out.println("Se hace una inicialización (id: " + id + ")" );
                        :} 
                        | listado_variables:lista OP_COMA ID:id {:
                            variables.push(id);
                            RESULT = crearNodo("listado_variables", (NodoArbol)lista, crearHoja((String)id));
                        :};

    //----------- Aritmetica

    operacion ::= operacion:izq OP_SUMA termino:der {: 
                        RESULT = crearNodo("+", (NodoArbol)izq, (NodoArbol)der);
                        System.out.println("Suma");
                    :}
            | operacion:izq OP_RESTA termino:der {: 
                        RESULT = crearNodo("-", (NodoArbol)izq, (NodoArbol)der);
                        System.out.println("Resta");
                    :}
            | termino:term {: RESULT = term; :};

    termino ::= termino:izq OP_MULT factor:der {: 
                        RESULT = crearNodo("*", (NodoArbol)izq, (NodoArbol)der);
                        System.out.println("Multiplicación");
                    :}
            | termino:izq OP_DIV factor:der {: 
                        RESULT = crearNodo("/", (NodoArbol)izq, (NodoArbol)der);
                        System.out.println("División");
                    :}
            | factor:fact {: RESULT = fact; :};

    factor ::= constante:constante {: RESULT = constante; :}
    | ID:id {:
                    String tipo = lyc.compiler.files.SymbolTableGenerator.GetTipo((String)id);
                    if (tipo == null) {
                        throw new RuntimeException("Error: variable '" + id + "' no declarada.");
                    }                    
                    RESULT = crearHoja((String)id);
                    System.out.println("Id: " + id);
                :}
    | PAR_ABRIR operacion:expr PAR_CERRAR {: RESULT = expr; :};

    //----------- Instrucciones condicional

    if ::= IF PAR_ABRIR condicion:cond PAR_CERRAR  
        LLAVE_ABRIR serie_de_instrucciones:instrucciones LLAVE_CERRAR
        else_opcional:elseInst {:
            RESULT = crearNodo("IF", crearNodo("condicion", (NodoArbol)cond, null), 
                              crearNodo("Cuerpo", (NodoArbol)instrucciones, (NodoArbol)elseInst));
            System.out.println("IF");
        :};

    else_opcional ::= ELSE 
                      LLAVE_ABRIR serie_de_instrucciones:instrucciones LLAVE_CERRAR {: 
                        RESULT = crearNodo("ELSE", (NodoArbol)instrucciones, null);
                        System.out.println("FIN ELSE");
                      :}
                      |
                      | ELSE if:ifInst {: 
                        RESULT = ifInst;
                        System.out.println("ELSE IF");
                      :};

    while ::= WHILE PAR_ABRIR condicion:cond PAR_CERRAR LLAVE_ABRIR serie_de_instrucciones:instrucciones LLAVE_CERRAR {: 
                RESULT = crearNodo("WHILE", crearNodo("CONDICION", (NodoArbol)cond, null), crearNodo("Cuerpo", (NodoArbol)instrucciones, null));
                System.out.println("WHILE"); 
            :};


    condicion ::= expresion_logica:expr {: 
                    RESULT = expr;
                    System.out.println("Expresión");
                :}
                | NOT expresion_logica:expr {: 
                    RESULT = crearNodo("NOT", (NodoArbol)expr, null);
                    System.out.println("NOT");
                :}
                | operation_is_zero:isZero {: 
                    RESULT = isZero;
                    System.out.println("Condición IsZero");
                :};



    expresion_logica ::= operacion:izq comparador:comp operacion:der {:
                            RESULT = crearNodo((String)comp, (NodoArbol)izq, (NodoArbol)der);
                        :}
                    | operacion:izq1 comparador:comp1 operacion:der1 AND operacion:izq2 comparador:comp2 operacion:der2 {:
                            NodoArbol expr1 = crearNodo((String)comp1, (NodoArbol)izq1, (NodoArbol)der1);
                            NodoArbol expr2 = crearNodo((String)comp2, (NodoArbol)izq2, (NodoArbol)der2);
                            RESULT = crearNodo("AND", expr1, expr2);
                        :}
                    | operacion:izq1 comparador:comp1 operacion:der1 OR operacion:izq2 comparador:comp2 operacion:der2 {:
                            NodoArbol expr1 = crearNodo((String)comp1, (NodoArbol)izq1, (NodoArbol)der1);
                            NodoArbol expr2 = crearNodo((String)comp2, (NodoArbol)izq2, (NodoArbol)der2);
                            RESULT = crearNodo("OR", expr1, expr2);
                        :};

    comparador ::= COMP_MEN {: 
                    RESULT = "<";
                    System.out.println("Operador menor");
                :}
                 | COMP_MAY {: 
                    RESULT = ">";
                    System.out.println("Operador mayor");
                :};


    //----------- Instrucciones entrada y salida
    read ::= READ PAR_ABRIR ID:id PAR_CERRAR {: 
                RESULT = crearNodo("READ", crearHoja((String)id), null);
                System.out.println("Se hizo una lectura. Lexema: " + (String)id);
            :};
    write ::= WRITE PAR_ABRIR parametro_write:param PAR_CERRAR {: 
                RESULT = crearNodo("WRITE", (NodoArbol)param, null);
                System.out.println("Se hizo una escritura. Lexema: " + ((NodoArbol)param).getValor() );
            :};
    parametro_write ::= ID:id {: RESULT = crearHoja((String)id); :} 
                      | CTE_CADENA:cadena {: RESULT = crearHoja((String)cadena); :};

    //----------- Instrucciones especiales

    parametros_operaciones ::= operacion:op {: RESULT = op; :} 
                            | parametros_operaciones:params OP_COMA operacion:op {:
                                RESULT = crearNodo("params_operacion", (NodoArbol)params, (NodoArbol)op);
                            :};

    operation_equal_expressions ::= EQUAL_EXPRESSIONS PAR_ABRIR parametros_operaciones:params PAR_CERRAR {: 
                RESULT = crearNodo("EQUAL_EXPRESSIONS", (NodoArbol)params, null);
                System.out.println("Se hizo Equal Expression");
            :};
    
    operation_is_zero ::= IS_ZERO PAR_ABRIR operacion:expr PAR_CERRAR {: 
                RESULT = crearNodo("IS_ZERO", (NodoArbol)expr, null);
                System.out.println("Se hizo Is Zero");
            :};
